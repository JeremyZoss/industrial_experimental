#!/usr/bin/env python

from __future__ import print_function   

import sys    
import os      
import argparse
import rospkg

import em

def print_menu():
  print("-------Motoman Package Generator-------")
  print("1. Generate support package")
  print("2. Generate additional moveit files")
  print("3. Exit")

def generate_moveit_package(model):
  print("Generating additional moveit files for model: ", model)
  moveit_package = "motoman_" + model + "_moveit_config"
  support_package = "motoman_" + model + "_support"
  generate_controller_manager_launch(moveit_package, model)
  generate_planning_execution_launch(moveit_package, support_package, model)
  touch(moveit_package + "/config/controllers.yaml")
  print("TODO: FILL IN CONTROLLERS YAML")
  print("TODO: CHECK JOINT LIMITS YAML FOR ACCEL/DECEL LIMITS")

def generate_support_package(model, author, author_email, version):
  print("Generating support directories for model: ", model)
  package = "motoman_" + model + "_support"
  #Populate package root directory
  mkdir(package)
  generate_cmakelist(package)
  generate_package_xml(package, model, author, author_email, version)
  #Populate package/config directory
  mkdir(package + "/config")
  print("Generating joint names yaml")
  touch(package + "/config/joint_names_" + model + ".yaml")
  #Populate package/launch directory
  mkdir(package + "/launch")
  generate_load_launch(package, model)
  generate_streaming_launch(package, model)
  generate_visualize_launch(package, model)
  generate_test_model_launch(package, model)
  #Populate package/meshes directory
  mkdir(package + "/meshes")
  mkdir(package + "/meshes/" + model)
  mkdir(package + "/meshes/" + model + "/collision")
  mkdir(package + "/meshes/" + model + "/visual")
  #Populate package/test directory
  mkdir(package + "/test")
  generate_launch_test(package, model)
  mkdir(package + "/urdf")
  touch(package + "/urdf/" + model + ".urdf")
  touch(package + "/urdf/" + model + ".xacro")
  touch(package + "/urdf/" + model + "_macro.xacro")

  print("TODO: FILL IN JOINT_NAMES YAML")
  print("TODO: ADD COLLISION/VISUAL MESHES")
  print("TODO: FILL IN URDF MACROS/URDFS")

def mkdir(path):
  try:
    os.mkdir(path)

  except OSError:
    print("Directory: " + path + " already exists, ignoring")

def touch(path):
  open(path, 'a').close()

def generate_cmakelist(package):
  print("Generate CMakeLists.txt")
  cmake_text = macros.cmakelist(package)
  fd = open(package + "/CMakeLists.txt", 'w')
  fd.write(cmake_text)
  
def generate_package_xml(package, model, author, author_email, version):
  print("Generating package.xml")
  package_text = macros.package_xml(package, model, author, author_email, version)
  fd = open(package + "/package.xml", 'w')
  fd.write(package_text)

def generate_load_launch(package, model):
  print("Generating load_" + model + ".launch")
  launch_text = macros.load_launch(package, model)
  fd = open(package + "/launch/load_" + model + ".launch", 'w')
  fd.write(launch_text)

def generate_streaming_launch(package, model):
  print("Generating robot_streaming_interface_" + model + ".launch")
  launch_text = macros.streaming_launch(package, model)
  fd = open(package + "/launch/robot_interface_streaming_" + model + ".launch", 'w')
  fd.write(launch_text)

def generate_visualize_launch(package, model):
  print("Generating robot_state_visualize_" + model + ".launch")
  launch_text = macros.state_vis_launch(package, model)
  fd = open(package + "/launch/robot_state_visualize_" + model + ".launch", 'w')
  fd.write(launch_text)

def generate_test_model_launch(package, model):
  print("Generating test_" + model + ".launch")
  launch_text = macros.test_model_launch(package, model)
  fd = open(package + "/launch/test_" + model + ".launch", 'w')
  fd.write(launch_text)

def generate_launch_test(package, model):
  print("Generating launch_test.xml")
  text = macros.launch_test(package, model)
  fd = open(package + "/test/launch_test.xml", 'w')
  fd.write(text)

def generate_controller_manager_launch(moveit_package, model):
  print("Generating motoman_" + model + "_moveit_controller_manager.launch.xml")
  text = macros.controller_manager_launch(moveit_package, model)
  fd = open(package + "/launch/motoman_" + model + "_moveit_controller_manager.launch.xml", 'w')
  fd.write(text)

def generate_planning_execution_launch(moveit_package, support_package, model):
  print("Generating moveit_planning_execution.launch")
  text = macros.planning_execution_launch(moveit_package, support_package, model)
  fd = open(package + "/launch/moveit_planning_execution.launch", 'w')
  fd = write(text)

def main():

  if len(sys.argv) < 5:
    print("Robot model, author, email & version required")
    sys.exit(1);

  model = sys.argv[1]
  author = sys.argv[2]
  author_email = sys.argv[3]
  version = sys.argv[4]

  print("Parsing model: ", model, " from command line")

  print_menu()
  item = input("Select an option: ")

  if item == 1:
    generate_support_package(model, author, author_email, version)
  elif item == 2:
    generate_moveit_package(model)

"""
package_generator

This class encapsulates functionality to generate standard ROS-I support and
MoveIt packages.  For the most part this class uses templates (em.py) to
generate package files.  This class can be customized by overriding private
generation methods.
"""
class package_generator():

  def __init__(self):
    pass
    
  def generate_moveit_package(model):
    print("Generating additional moveit files for model: ", model)
    moveit_package = "motoman_" + model + "_moveit_config"
    support_package = "motoman_" + model + "_support"
    generate_controller_manager_launch(moveit_package, model)
    generate_planning_execution_launch(moveit_package, support_package, model)
    touch(moveit_package + "/config/controllers.yaml")
    print("TODO: FILL IN CONTROLLERS YAML")
    print("TODO: CHECK JOINT LIMITS YAML FOR ACCEL/DECEL LIMITS")

  def generate_support_package(prefix, model, num_joints, author, author_email, version, template_path):
    print("Generating support directories for model: ", model)
    if len(prefix) > 0:
      package = model + '_support'
    else:
      package = prefix + '_' + model + '_support'
    #Populate package root directory
    mkdir(package)
    generate_cmakelist(package)
    generate_package_xml(package, model, author, author_email, version)
    #Populate package/config directory
    mkdir(package + "/config")
    print("Generating joint names yaml")
    ## TODO: remove touch command when joint names yaml generator is implemented
    self.__generate_joint_names_yaml__(num_joints)
    #Populate package/launch directory
    mkdir(package + "/launch")
    generate_load_launch(package, model)
    generate_streaming_launch(package, model)
    generate_visualize_launch(package, model)
    generate_test_model_launch(package, model)
    #Populate package/meshes directory
    mkdir(package + "/meshes")
    mkdir(package + "/meshes/" + model)
    mkdir(package + "/meshes/" + model + "/collision")
    mkdir(package + "/meshes/" + model + "/visual")
    #Populate package/test directory
    mkdir(package + "/test")
    generate_launch_test(package, model)
    mkdir(package + "/urdf")
    touch(package + "/urdf/" + model + ".urdf")
    touch(package + "/urdf/" + model + ".xacro")
    touch(package + "/urdf/" + model + "_macro.xacro")

    print("TODO: FILL IN JOINT_NAMES YAML")
    print("TODO: ADD COLLISION/VISUAL MESHES")
    print("TODO: FILL IN URDF MACROS/URDFS")

  def generate_cmakelist(package):
    print("Generate CMakeLists.txt")
    cmake_text = macros.cmakelist(package)
    fd = open(package + "/CMakeLists.txt", 'w')
    fd.write(cmake_text)
    
  def generate_package_xml(package, model, author, author_email, version):
    print("Generating package.xml")
    package_text = macros.package_xml(package, model, author, author_email, version)
    fd = open(package + "/package.xml", 'w')
    fd.write(package_text)
    
  def __generate_joint_names_yaml__(num_joints):
    print("Generating joint names yaml NOT IMPLEMENTED")

  def generate_load_launch(package, model):
    print("Generating load_" + model + ".launch")
    launch_text = macros.load_launch(package, model)
    fd = open(package + "/launch/load_" + model + ".launch", 'w')
    fd.write(launch_text)

  def generate_streaming_launch(package, model):
    print("Generating robot_streaming_interface_" + model + ".launch")
    launch_text = macros.streaming_launch(package, model)
    fd = open(package + "/launch/robot_interface_streaming_" + model + ".launch", 'w')
    fd.write(launch_text)

  def generate_visualize_launch(package, model):
    print("Generating robot_state_visualize_" + model + ".launch")
    launch_text = macros.state_vis_launch(package, model)
    fd = open(package + "/launch/robot_state_visualize_" + model + ".launch", 'w')
    fd.write(launch_text)

  def generate_test_model_launch(package, model):
    print("Generating test_" + model + ".launch")
    launch_text = macros.test_model_launch(package, model)
    fd = open(package + "/launch/test_" + model + ".launch", 'w')
    fd.write(launch_text)

  def generate_launch_test(package, model):
    print("Generating launch_test.xml")
    text = macros.launch_test(package, model)
    fd = open(package + "/test/launch_test.xml", 'w')
    fd.write(text)

  def generate_controller_manager_launch(moveit_package, model):
    print("Generating motoman_" + model + "_moveit_controller_manager.launch.xml")
    text = macros.controller_manager_launch(moveit_package, model)
    fd = open(package + "/launch/motoman_" + model + "_moveit_controller_manager.launch.xml", 'w')
    fd.write(text)

  def generate_planning_execution_launch(moveit_package, support_package, model):
    print("Generating moveit_planning_execution.launch")
    text = macros.planning_execution_launch(moveit_package, support_package, model)
    fd = open(package + "/launch/moveit_planning_execution.launch", 'w')
    fd = write(text)
    
    
    
    
    
    
    
    """
support_package_generator

This class encapsulates functionality to generate standard ROS-I support 
packages.  This class uses templates (em.py) to generate package files.
Templates can be changed to alter the generated files.
"""
class support_package_generator():

  def __init__(self):
    pass
    
  def generate_package(self, prefix, model, num_joints, author, author_email, version, template_path):
    print("Generating support directories for model: ", model)
    
    #Handling special parameters
    if prefix:
      package = prefix + '_' + model + '_support'
    else:
      package = model + '_support'
    
    #Load arguments into em params
    em_params = self.__load_em_params__(package, model, num_joints, author, author_email, version, template_path)
        
    #Populate package root directory
    file_path = package
    mkdir(file_path)
    self.__generate_cmakelist__(em_params, template_path, file_path)
    self.__generate_package_xml__(em_params, template_path, file_path)
    
    #Populate package/config directory
    file_path = package + "/config"
    mkdir(file_path)
    self.__generate_joint_names_yaml__(em_params, template_path, file_path)

    #Populate package/launch directory
    file_path = package + "/launch"
    mkdir(file_path)
    self.__generate_load_launch__(em_params, template_path, file_path)
    self.__generate_interface_launch__(em_params, template_path, file_path)
    self.__generate_visualize_launch__(em_params, template_path, file_path)
    self.__generate_test_model_launch__(em_params, template_path, file_path)
    #Populate package/meshes directory
    mkdir(package + "/meshes")
    mkdir(package + "/meshes/" + model)
    mkdir(package + "/meshes/" + model + "/collision")
    mkdir(package + "/meshes/" + model + "/visual")
    #Populate package/test directory
    mkdir(package + "/test")
    self.__generate_launch_test__(em_params, template_path, file_path)
    mkdir(package + "/urdf")
    touch(package + "/urdf/" + model + ".urdf")
    touch(package + "/urdf/" + model + ".xacro")
    touch(package + "/urdf/" + model + "_macro.xacro")

    print("TODO: ADD COLLISION/VISUAL MESHES")
    print("TODO: FILL IN URDF MACROS/URDFS")
    
  def __load_em_params__(self, package, model, num_joints, author, author_email, version, template_path):
    
    #Load empy parameters
    em_params = {}
    em.expand('@{package = "' + package + '"}', em_params)
    em.expand('@{model = "' + model + '"}', em_params)
    em.expand('@{num_joints = "' + str(num_joints) + '"}', em_params)
    em.expand('@{author = "' + author + '"}', em_params)
    em.expand('@{email = "' + author_email + '"}', em_params)
    em.expand('@{pkg_vers = "' + package + '"}', em_params)
    
    return em_params
    
  def __generate_empy_file__(self, em_params, template_path, template_name, file_path, file_name):
    print("Generating " + file_name)
    template_file = template_path + "/" + template_name
    print("Loading template file: " + template_file)
        
    f = open(template_file, 'r')
    text = em.expand(f.read(), em_params)
    package_file = file_path + "/" + file_name
    
    if(text):
      print("Outputting package file: " + package_file)
      fd = open(package_file, 'w')
      fd.write(text)
    else:
      print("Generated package file: " + package_file + ", contents empty, no file created")
    
  def __generate_cmakelist__(self, em_params, template_path, file_path):
    self.__generate_empy_file__(em_params, template_path, "CMakeLists.empy", file_path, "CMakeLists.txt")
    
  def __generate_package_xml__(self, em_params, template_path, file_path):
    self.__generate_empy_file__(em_params, template_path, "package.empy", file_path, "package.xml")
    
  def __generate_joint_names_yaml__(self, em_params, template_path, file_path):
    file_name = "joint_names_" + em_params.get('model') + ".yaml"
    self.__generate_empy_file__(em_params, template_path, "joint_names.empy", file_path, file_name)

  def __generate_load_launch__(self, em_params, template_path, file_path):
    file_name = "load_" + em_params.get('model')  + ".launch"
    self.__generate_empy_file__(em_params, template_path, "load_launch.empy", file_path, file_name)
    
  def __generate_interface_launch__(self, em_params, template_path, file_path):
    file_name = "robot_streaming_interface_" + em_params.get('model') + ".launch"
    self.__generate_empy_file__(em_params, template_path, "streaming_interface.empy", file_path, file_name)
    file_name = "robot_download_interface_" + em_params.get('model') + ".launch"
    self.__generate_empy_file__(em_params, template_path, "download_interface.empy", file_path, file_name)

  def __generate_visualize_launch__(self, em_params, template_path, file_path):
    file_name = "robot_state_visualize_" + em_params.get('model')  + ".launch"
    self.__generate_empy_file__(em_params, template_path, "robot_state_visualize.empy", file_path, file_name)

  def __generate_test_model_launch__(self, em_params, template_path, file_path):
    file_name = "test_" + em_params.get('model')  + ".launch"
    self.__generate_empy_file__(em_params, template_path, "test_model.empy", file_path, file_name)

  def __generate_launch_test__(self, em_params, template_path, file_path):
    self.__generate_empy_file__(em_params, template_path, "launch_test.empy", file_path, "launch_test.xml")

  def generate_controller_manager_launch(moveit_package, model):
    print("Generating motoman_" + model + "_moveit_controller_manager.launch.xml")
    text = macros.controller_manager_launch(moveit_package, model)
    fd = open(package + "/launch/motoman_" + model + "_moveit_controller_manager.launch.xml", 'w')
    fd.write(text)

  def generate_planning_execution_launch(moveit_package, support_package, model):
    print("Generating moveit_planning_execution.launch")
    text = macros.planning_execution_launch(moveit_package, support_package, model)
    fd = open(package + "/launch/moveit_planning_execution.launch", 'w')
    fd = write(text)







"""
sub_cmd_base

This base class is an interface definition for sub commands entered on the
command line.  This class encapsulates parsing and execution methods.
"""
class sub_cmd_base:
  
  def __init__(self, subparser):
    pass
    
  def add_to_subparser(self, subparser):
    pass
    
  def __execute__(self):
    pass
    
"""
support_sub_cmd
"""
class support_sub_cmd(sub_cmd_base):

  def __init__(self):
    self.name = 'support'
    
  def add_to_subparser(self, subparser):
    parser_support = subparser.add_parser(self.name, description='Creates ROS-Industrial support package')
    parser_support.add_argument('model', help='robot model number')
    parser_support.add_argument('email', help='author email')
    parser_support.add_argument('--dof', type=int, default=6, help='number of robot dof(joints)')
    parser_support.add_argument('--pkg_vers', default= '0.0.1', help='package version number')
    parser_support.add_argument('--author', default= None, help='author name')
    parser_support.add_argument('--prefix', default= None, help='prefix to be added to package name (typically meta-package name)')
    parser_support.add_argument('--t_pkg', default= 'industrial_robot_pkg_gen', help='package that contains templates')
    parser_support.add_argument('--t_path', default= 'resources', help='template(em.py) path, relative to package specified by t_pkg argument')
    parser_support.set_defaults(func=self.__execute__)
    
  def __execute__(self, args):
    print(args)

    # allows us to get the package path
    rospack = rospkg.RosPack()
    template_path = rospack.get_path(args.t_pkg) + '/' + args.t_path
    print("Template path: " + template_path)
    
    # Author email used in place of empty author name
    if(not args.author): args.author = args.email
    
    generator = support_package_generator()
    generator.generate_package(args.prefix, args.model, args.dof, args.author, args.email, args.pkg_vers, template_path)

    





      
"""
cmd_line_interface

This class encapsulates the package generator command line interface (CLI).  
Sub-commands are added via the add_sub_cmd method.  This allows the class
to dynamically add commands for package generation (including specialized
commands for specific packages).
"""  
class cmd_line_interface:


  """
  Constructor command line interface object
  
  """
  def __init__(self):
    
    self.parser = argparse.ArgumentParser(description='Creates ROS-Industrial vendor robot package')
    self.subparsers = self.parser.add_subparsers()

  def add_sub_cmd(self, sub_cmd):
    sub_cmd.add_to_subparser(self.subparsers)
 
  def run(self):
    
    args = self.parser.parse_args()
    args.func(args)







if __name__ == '__main__':

  cli = cmd_line_interface()
  cli.add_sub_cmd(support_sub_cmd())
  cli.run()



